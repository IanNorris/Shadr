void TestUnarySignEdgeCases( void )
{
	int i = 0;
	-i;
	+i;
	-3-3;
	+3-+3;
	-3-3;
	-4+-4;
	-i+++4;
	3+1;
	3-1;
	3.0f-1.0f;
	1111.e4f+1151.12e13f;
}

void TestTernary( void )
{
	float f0 = 0.0f, f1 = 1.0f, f2 = 2.0f;

	if( f0 > f1 ? f0 : f1 )
	{
		
	}
	
	int i = f1 > (f2-f1) ? f0 + 3 : f2 - 3;
	
	//This one previously failed because f2-3 was interpreted as "identifier int" and not "identifier minus int"
	int j = f1 > (f2-f1) ? f0+3 : f2-3;
	
	int k = f1 > (f2 - f1) ? (f2 <= f1 ? f0 : f1) : f2 - 3;
	int l = f1 > (f2 - f1) ? (f2 <= f1 ? f0 : f1) : (f0 <= 3 ? f2 : 1.0f);
	int m = f1 > (f2 - f1) ? f2 <= f1 ? f0 / 4 : f1 * 2 + 1 : f0 <= 3 ? k + 3.0f : 1.0f;
	
}

const float TestWhile()
{
	int i,j,l;
	l = +j ---i - i--;

	i = 100;
	i++;
	++i;
	
	j = 1;
	float fVal = 1;
	while( i <= 100 )
	{
		i = i - 1;
		fVal *= 2;
		j <<= 1;
	}
	
	i = 100;
	do{
		i -= 1;
	}while( i >= 3 );
	
	for( int k = 0; k < 100; ++k )
	{
	
	}
	
	return fVal;
}

float4 MyFunction( float3 fIn1, int iCount, float4 fVal3, float fStuff, bool bIsTrue )
{
	int3 myVar2;
	int myVar3, myVar4;
	int myVar6 = 2, myVar7 = iCount + 2;
	
	fIn1 = 3;
	
	fStuff = fIn1 + fIn1 + (fStuff = fVal3 * 3);
	
	if( bIsTrue && (fIn1 + 4) > 0 )
	{
		return 2;
	}
	else
	{
		return fVal3;
	}

	return 1;
}

float4 PSMain()
{
	int i = 3;
	
	//Token ambiguity here
	//float4 f4Val = MakeFloat4( 2.0, 1.0f, -3.0f, 1 );
	float4 f4Val = MakeFloat4( 2.0, 1.0f, 3.0f, 1 );

	float4 f4Result = MyFunction( f4Val.xyz, i, f4Val, f4Val.x, true );
	float fIn1 = 4;
	if( fIn1 / 2 /* hello */ ) //test
	{
		return 2;
	}

	return 0;
}